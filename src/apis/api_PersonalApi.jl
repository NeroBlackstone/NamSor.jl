# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct PersonalApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `PersonalApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ PersonalApi }) = "https://v2.namsor.com/NamSorAPIv2"

const _returntypes_community_engage_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => CommunityEngageOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_community_engage(_api::PersonalApi, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_community_engage_PersonalApi, "/api2/json/communityEngage/{countryIso2}/{firstName}/{lastName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)

Params:
- country_iso2::String (required)
- first_name::String (required)
- last_name::String (required)

Return: CommunityEngageOut, OpenAPI.Clients.ApiResponse
"""
function community_engage(_api::PersonalApi, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_community_engage(_api, country_iso2, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function community_engage(_api::PersonalApi, response_stream::Channel, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_community_engage(_api, country_iso2, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_community_engage_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchCommunityEngageOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_community_engage_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_community_engage_batch_PersonalApi, "/api2/json/communityEngageBatch", ["api_key", ], batch_first_last_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)

Params:
- batch_first_last_name_geo_in::BatchFirstLastNameGeoIn

Return: BatchCommunityEngageOut, OpenAPI.Clients.ApiResponse
"""
function community_engage_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_community_engage_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function community_engage_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_community_engage_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_community_engage_full_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => CommunityEngageOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_community_engage_full(_api::PersonalApi, country_iso2::String, personal_name_full::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_community_engage_full_PersonalApi, "/api2/json/communityEngageFull/{countryIso2}/{personalNameFull}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "personalNameFull", personal_name_full)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)

Params:
- country_iso2::String (required)
- personal_name_full::String (required)

Return: CommunityEngageOut, OpenAPI.Clients.ApiResponse
"""
function community_engage_full(_api::PersonalApi, country_iso2::String, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_community_engage_full(_api, country_iso2, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function community_engage_full(_api::PersonalApi, response_stream::Channel, country_iso2::String, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_community_engage_full(_api, country_iso2, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_community_engage_full_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchCommunityEngageFullOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_community_engage_full_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_community_engage_full_batch_PersonalApi, "/api2/json/communityEngageFullBatch", ["api_key", ], batch_personal_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)

Params:
- batch_personal_name_geo_in::BatchPersonalNameGeoIn

Return: BatchCommunityEngageFullOut, OpenAPI.Clients.ApiResponse
"""
function community_engage_full_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_community_engage_full_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function community_engage_full_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_community_engage_full_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_corridor_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => CorridorOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_corridor(_api::PersonalApi, country_iso2_from::String, first_name_from::String, last_name_from::String, country_iso2_to::String, first_name_to::String, last_name_to::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_corridor_PersonalApi, "/api2/json/corridor/{countryIso2From}/{firstNameFrom}/{lastNameFrom}/{countryIso2To}/{firstNameTo}/{lastNameTo}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2From", country_iso2_from)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "firstNameFrom", first_name_from)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastNameFrom", last_name_from)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2To", country_iso2_to)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "firstNameTo", first_name_to)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastNameTo", last_name_to)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)

Params:
- country_iso2_from::String (required)
- first_name_from::String (required)
- last_name_from::String (required)
- country_iso2_to::String (required)
- first_name_to::String (required)
- last_name_to::String (required)

Return: CorridorOut, OpenAPI.Clients.ApiResponse
"""
function corridor(_api::PersonalApi, country_iso2_from::String, first_name_from::String, last_name_from::String, country_iso2_to::String, first_name_to::String, last_name_to::String; _mediaType=nothing)
    _ctx = _oacinternal_corridor(_api, country_iso2_from, first_name_from, last_name_from, country_iso2_to, first_name_to, last_name_to; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function corridor(_api::PersonalApi, response_stream::Channel, country_iso2_from::String, first_name_from::String, last_name_from::String, country_iso2_to::String, first_name_to::String, last_name_to::String; _mediaType=nothing)
    _ctx = _oacinternal_corridor(_api, country_iso2_from, first_name_from, last_name_from, country_iso2_to, first_name_to, last_name_to; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_corridor_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchCorridorOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_corridor_batch(_api::PersonalApi; batch_corridor_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_corridor_batch_PersonalApi, "/api2/json/corridorBatch", ["api_key", ], batch_corridor_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)

Params:
- batch_corridor_in::BatchCorridorIn

Return: BatchCorridorOut, OpenAPI.Clients.ApiResponse
"""
function corridor_batch(_api::PersonalApi; batch_corridor_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_corridor_batch(_api; batch_corridor_in=batch_corridor_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function corridor_batch(_api::PersonalApi, response_stream::Channel; batch_corridor_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_corridor_batch(_api; batch_corridor_in=batch_corridor_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_country_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameGeoOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_country(_api::PersonalApi, personal_name_full::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_country_PersonalApi, "/api2/json/country/{personalNameFull}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "personalNameFull", personal_name_full)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.

Params:
- personal_name_full::String (required)

Return: PersonalNameGeoOut, OpenAPI.Clients.ApiResponse
"""
function country(_api::PersonalApi, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_country(_api, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function country(_api::PersonalApi, response_stream::Channel, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_country(_api, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_country_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameGeoOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_country_batch(_api::PersonalApi; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_country_batch_PersonalApi, "/api2/json/countryBatch", ["api_key", ], batch_personal_name_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.

Params:
- batch_personal_name_in::BatchPersonalNameIn

Return: BatchPersonalNameGeoOut, OpenAPI.Clients.ApiResponse
"""
function country_batch(_api::PersonalApi; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_country_batch(_api; batch_personal_name_in=batch_personal_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function country_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_country_batch(_api; batch_personal_name_in=batch_personal_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_country_fn_ln_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameOriginedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_country_fn_ln(_api::PersonalApi, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_country_fn_ln_PersonalApi, "/api2/json/countryFnLn/{firstName}/{lastName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely country of residence of a personal first / last name, or one surname. Assumes names as they are in the country of residence OR the country of origin.

Params:
- first_name::String (required)
- last_name::String (required)

Return: FirstLastNameOriginedOut, OpenAPI.Clients.ApiResponse
"""
function country_fn_ln(_api::PersonalApi, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_country_fn_ln(_api, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function country_fn_ln(_api::PersonalApi, response_stream::Channel, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_country_fn_ln(_api, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_country_fn_ln_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameGeoOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_country_fn_ln_batch(_api::PersonalApi; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_country_fn_ln_batch_PersonalApi, "/api2/json/countryFnLnBatch", ["api_key", ], batch_first_last_name_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal first / last names, or surnames. Assumes names as they are in the country of residence OR the country of origin.

Params:
- batch_first_last_name_in::BatchFirstLastNameIn

Return: BatchFirstLastNameGeoOut, OpenAPI.Clients.ApiResponse
"""
function country_fn_ln_batch(_api::PersonalApi; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_country_fn_ln_batch(_api; batch_first_last_name_in=batch_first_last_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function country_fn_ln_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_country_fn_ln_batch(_api; batch_first_last_name_in=batch_first_last_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_diaspora_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameDiasporaedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_diaspora(_api::PersonalApi, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_diaspora_PersonalApi, "/api2/json/diaspora/{countryIso2}/{firstName}/{lastName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)

Params:
- country_iso2::String (required)
- first_name::String (required)
- last_name::String (required)

Return: FirstLastNameDiasporaedOut, OpenAPI.Clients.ApiResponse
"""
function diaspora(_api::PersonalApi, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_diaspora(_api, country_iso2, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function diaspora(_api::PersonalApi, response_stream::Channel, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_diaspora(_api, country_iso2, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_diaspora_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameDiasporaedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_diaspora_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_diaspora_batch_PersonalApi, "/api2/json/diasporaBatch", ["api_key", ], batch_first_last_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)

Params:
- batch_first_last_name_geo_in::BatchFirstLastNameGeoIn

Return: BatchFirstLastNameDiasporaedOut, OpenAPI.Clients.ApiResponse
"""
function diaspora_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_diaspora_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function diaspora_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_diaspora_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_diaspora_full_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameDiasporaedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_diaspora_full(_api::PersonalApi, country_iso2::String, personal_name_full::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_diaspora_full_PersonalApi, "/api2/json/diasporaFull/{countryIso2}/{personalNameFull}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "personalNameFull", personal_name_full)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)

Params:
- country_iso2::String (required)
- personal_name_full::String (required)

Return: PersonalNameDiasporaedOut, OpenAPI.Clients.ApiResponse
"""
function diaspora_full(_api::PersonalApi, country_iso2::String, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_diaspora_full(_api, country_iso2, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function diaspora_full(_api::PersonalApi, response_stream::Channel, country_iso2::String, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_diaspora_full(_api, country_iso2, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_diaspora_full_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameDiasporaedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_diaspora_full_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_diaspora_full_batch_PersonalApi, "/api2/json/diasporaFullBatch", ["api_key", ], batch_personal_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)

Params:
- batch_personal_name_geo_in::BatchPersonalNameGeoIn

Return: BatchPersonalNameDiasporaedOut, OpenAPI.Clients.ApiResponse
"""
function diaspora_full_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_diaspora_full_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function diaspora_full_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_diaspora_full_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender(_api::PersonalApi, first_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_gender_PersonalApi, "/api2/json/gender/{firstName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of a just a fiven name, assuming default 'US' local context. Please use preferably full names and local geographic context for better accuracy.

Params:
- first_name::String (required)

Return: FirstLastNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender(_api::PersonalApi, first_name::String; _mediaType=nothing)
    _ctx = _oacinternal_gender(_api, first_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender(_api::PersonalApi, response_stream::Channel, first_name::String; _mediaType=nothing)
    _ctx = _oacinternal_gender(_api, first_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender1_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender1(_api::PersonalApi, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_gender1_PersonalApi, "/api2/json/gender/{firstName}/{lastName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of a name.

Params:
- first_name::String (required)
- last_name::String (required)

Return: FirstLastNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender1(_api::PersonalApi, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_gender1(_api, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender1(_api::PersonalApi, response_stream::Channel, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_gender1(_api, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender_batch(_api::PersonalApi; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_gender_batch_PersonalApi, "/api2/json/genderBatch", ["api_key", ], batch_first_last_name_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of up to 100 names, detecting automatically the cultural context.

Params:
- batch_first_last_name_in::BatchFirstLastNameIn

Return: BatchFirstLastNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender_batch(_api::PersonalApi; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_gender_batch(_api; batch_first_last_name_in=batch_first_last_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_gender_batch(_api; batch_first_last_name_in=batch_first_last_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender_full_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender_full(_api::PersonalApi, full_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_gender_full_PersonalApi, "/api2/json/genderFull/{fullName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "fullName", full_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of a full name, ex. John H. Smith

Params:
- full_name::String (required)

Return: PersonalNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender_full(_api::PersonalApi, full_name::String; _mediaType=nothing)
    _ctx = _oacinternal_gender_full(_api, full_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender_full(_api::PersonalApi, response_stream::Channel, full_name::String; _mediaType=nothing)
    _ctx = _oacinternal_gender_full(_api, full_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender_full_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender_full_batch(_api::PersonalApi; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_gender_full_batch_PersonalApi, "/api2/json/genderFullBatch", ["api_key", ], batch_personal_name_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of up to 100 full names, detecting automatically the cultural context.

Params:
- batch_personal_name_in::BatchPersonalNameIn

Return: BatchPersonalNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender_full_batch(_api::PersonalApi; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_gender_full_batch(_api; batch_personal_name_in=batch_personal_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender_full_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_gender_full_batch(_api; batch_personal_name_in=batch_personal_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender_full_geo_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender_full_geo(_api::PersonalApi, full_name::String, country_iso2::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_gender_full_geo_PersonalApi, "/api2/json/genderFullGeo/{fullName}/{countryIso2}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "fullName", full_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of a full name, given a local context (ISO2 country code).

Params:
- full_name::String (required)
- country_iso2::String (required)

Return: PersonalNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender_full_geo(_api::PersonalApi, full_name::String, country_iso2::String; _mediaType=nothing)
    _ctx = _oacinternal_gender_full_geo(_api, full_name, country_iso2; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender_full_geo(_api::PersonalApi, response_stream::Channel, full_name::String, country_iso2::String; _mediaType=nothing)
    _ctx = _oacinternal_gender_full_geo(_api, full_name, country_iso2; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender_full_geo_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender_full_geo_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_gender_full_geo_batch_PersonalApi, "/api2/json/genderFullGeoBatch", ["api_key", ], batch_personal_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).

Params:
- batch_personal_name_geo_in::BatchPersonalNameGeoIn

Return: BatchPersonalNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender_full_geo_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_gender_full_geo_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender_full_geo_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_gender_full_geo_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender_geo_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender_geo(_api::PersonalApi, first_name::String, last_name::String, country_iso2::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_gender_geo_PersonalApi, "/api2/json/genderGeo/{firstName}/{lastName}/{countryIso2}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of a name, given a local context (ISO2 country code).

Params:
- first_name::String (required)
- last_name::String (required)
- country_iso2::String (required)

Return: FirstLastNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender_geo(_api::PersonalApi, first_name::String, last_name::String, country_iso2::String; _mediaType=nothing)
    _ctx = _oacinternal_gender_geo(_api, first_name, last_name, country_iso2; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender_geo(_api::PersonalApi, response_stream::Channel, first_name::String, last_name::String, country_iso2::String; _mediaType=nothing)
    _ctx = _oacinternal_gender_geo(_api, first_name, last_name, country_iso2; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_gender_geo_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameGenderedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_gender_geo_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_gender_geo_batch_PersonalApi, "/api2/json/genderGeoBatch", ["api_key", ], batch_first_last_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).

Params:
- batch_first_last_name_geo_in::BatchFirstLastNameGeoIn

Return: BatchFirstLastNameGenderedOut, OpenAPI.Clients.ApiResponse
"""
function gender_geo_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_gender_geo_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function gender_geo_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_gender_geo_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_origin_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameOriginedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_origin(_api::PersonalApi, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_origin_PersonalApi, "/api2/json/origin/{firstName}/{lastName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use 'diaspora' instead.

Params:
- first_name::String (required)
- last_name::String (required)

Return: FirstLastNameOriginedOut, OpenAPI.Clients.ApiResponse
"""
function origin(_api::PersonalApi, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_origin(_api, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function origin(_api::PersonalApi, response_stream::Channel, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_origin(_api, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_origin_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameOriginedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_origin_batch(_api::PersonalApi; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_origin_batch_PersonalApi, "/api2/json/originBatch", ["api_key", ], batch_first_last_name_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.

Params:
- batch_first_last_name_in::BatchFirstLastNameIn

Return: BatchFirstLastNameOriginedOut, OpenAPI.Clients.ApiResponse
"""
function origin_batch(_api::PersonalApi; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_origin_batch(_api; batch_first_last_name_in=batch_first_last_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function origin_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_origin_batch(_api; batch_first_last_name_in=batch_first_last_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_origin_full_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameOriginedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_origin_full(_api::PersonalApi, personal_name_full::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_origin_full_PersonalApi, "/api2/json/originFull/{personalNameFull}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "personalNameFull", personal_name_full)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use 'diaspora' instead.

Params:
- personal_name_full::String (required)

Return: PersonalNameOriginedOut, OpenAPI.Clients.ApiResponse
"""
function origin_full(_api::PersonalApi, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_origin_full(_api, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function origin_full(_api::PersonalApi, response_stream::Channel, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_origin_full(_api, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_origin_full_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameOriginedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_origin_full_batch(_api::PersonalApi; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_origin_full_batch_PersonalApi, "/api2/json/originFullBatch", ["api_key", ], batch_personal_name_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.

Params:
- batch_personal_name_in::BatchPersonalNameIn

Return: BatchPersonalNameOriginedOut, OpenAPI.Clients.ApiResponse
"""
function origin_full_batch(_api::PersonalApi; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_origin_full_batch(_api; batch_personal_name_in=batch_personal_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function origin_full_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_origin_full_batch(_api; batch_personal_name_in=batch_personal_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_parse_name_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameParsedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_parse_name(_api::PersonalApi, name_full::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_parse_name_PersonalApi, "/api2/json/parseName/{nameFull}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "nameFull", name_full)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. 

Params:
- name_full::String (required)

Return: PersonalNameParsedOut, OpenAPI.Clients.ApiResponse
"""
function parse_name(_api::PersonalApi, name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_parse_name(_api, name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function parse_name(_api::PersonalApi, response_stream::Channel, name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_parse_name(_api, name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_parse_name_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameParsedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_parse_name_batch(_api::PersonalApi; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_parse_name_batch_PersonalApi, "/api2/json/parseNameBatch", ["api_key", ], batch_personal_name_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.

Params:
- batch_personal_name_in::BatchPersonalNameIn

Return: BatchPersonalNameParsedOut, OpenAPI.Clients.ApiResponse
"""
function parse_name_batch(_api::PersonalApi; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_parse_name_batch(_api; batch_personal_name_in=batch_personal_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function parse_name_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_parse_name_batch(_api; batch_personal_name_in=batch_personal_name_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_parse_name_geo_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameParsedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_parse_name_geo(_api::PersonalApi, name_full::String, country_iso2::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_parse_name_geo_PersonalApi, "/api2/json/parseName/{nameFull}/{countryIso2}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "nameFull", name_full)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.

Params:
- name_full::String (required)
- country_iso2::String (required)

Return: PersonalNameParsedOut, OpenAPI.Clients.ApiResponse
"""
function parse_name_geo(_api::PersonalApi, name_full::String, country_iso2::String; _mediaType=nothing)
    _ctx = _oacinternal_parse_name_geo(_api, name_full, country_iso2; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function parse_name_geo(_api::PersonalApi, response_stream::Channel, name_full::String, country_iso2::String; _mediaType=nothing)
    _ctx = _oacinternal_parse_name_geo(_api, name_full, country_iso2; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_parse_name_geo_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameParsedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_parse_name_geo_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_parse_name_geo_batch_PersonalApi, "/api2/json/parseNameGeoBatch", ["api_key", ], batch_personal_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision. 

Params:
- batch_personal_name_geo_in::BatchPersonalNameGeoIn

Return: BatchPersonalNameParsedOut, OpenAPI.Clients.ApiResponse
"""
function parse_name_geo_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_parse_name_geo_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function parse_name_geo_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_parse_name_geo_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_religion2_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameReligionedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_religion2(_api::PersonalApi, country_iso2::String, sub_division_iso31662::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_religion2_PersonalApi, "/api2/json/religion/{countryIso2}/{subDivisionIso31662}/{firstName}/{lastName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "subDivisionIso31662", sub_division_iso31662)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).

Params:
- country_iso2::String (required)
- sub_division_iso31662::String (required)
- first_name::String (required)
- last_name::String (required)

Return: FirstLastNameReligionedOut, OpenAPI.Clients.ApiResponse
"""
function religion2(_api::PersonalApi, country_iso2::String, sub_division_iso31662::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_religion2(_api, country_iso2, sub_division_iso31662, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function religion2(_api::PersonalApi, response_stream::Channel, country_iso2::String, sub_division_iso31662::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_religion2(_api, country_iso2, sub_division_iso31662, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_religion_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameReligionedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_religion_batch(_api::PersonalApi; batch_first_last_name_geo_subdivision_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_religion_batch_PersonalApi, "/api2/json/religionBatch", ["api_key", ], batch_first_last_name_geo_subdivision_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.

Params:
- batch_first_last_name_geo_subdivision_in::BatchFirstLastNameGeoSubdivisionIn

Return: BatchFirstLastNameReligionedOut, OpenAPI.Clients.ApiResponse
"""
function religion_batch(_api::PersonalApi; batch_first_last_name_geo_subdivision_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_religion_batch(_api; batch_first_last_name_geo_subdivision_in=batch_first_last_name_geo_subdivision_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function religion_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_geo_subdivision_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_religion_batch(_api; batch_first_last_name_geo_subdivision_in=batch_first_last_name_geo_subdivision_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_religion_full_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameReligionedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_religion_full(_api::PersonalApi, country_iso2::String, sub_division_iso31662::String, personal_name_full::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_religion_full_PersonalApi, "/api2/json/religionFull/{countryIso2}/{subDivisionIso31662}/{personalNameFull}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "subDivisionIso31662", sub_division_iso31662)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "personalNameFull", personal_name_full)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).

Params:
- country_iso2::String (required)
- sub_division_iso31662::String (required)
- personal_name_full::String (required)

Return: PersonalNameReligionedOut, OpenAPI.Clients.ApiResponse
"""
function religion_full(_api::PersonalApi, country_iso2::String, sub_division_iso31662::String, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_religion_full(_api, country_iso2, sub_division_iso31662, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function religion_full(_api::PersonalApi, response_stream::Channel, country_iso2::String, sub_division_iso31662::String, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_religion_full(_api, country_iso2, sub_division_iso31662, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_religion_full_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameReligionedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_religion_full_batch(_api::PersonalApi; batch_personal_name_geo_subdivision_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_religion_full_batch_PersonalApi, "/api2/json/religionFullBatch", ["api_key", ], batch_personal_name_geo_subdivision_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.

Params:
- batch_personal_name_geo_subdivision_in::BatchPersonalNameGeoSubdivisionIn

Return: BatchPersonalNameReligionedOut, OpenAPI.Clients.ApiResponse
"""
function religion_full_batch(_api::PersonalApi; batch_personal_name_geo_subdivision_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_religion_full_batch(_api; batch_personal_name_geo_subdivision_in=batch_personal_name_geo_subdivision_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function religion_full_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_geo_subdivision_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_religion_full_batch(_api; batch_personal_name_geo_subdivision_in=batch_personal_name_geo_subdivision_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_subclassification_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameGeoSubclassificationOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_subclassification(_api::PersonalApi, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_subclassification_PersonalApi, "/api2/json/subclassification/{countryIso2}/{firstName}/{lastName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code 'IN').

Params:
- country_iso2::String (required)
- first_name::String (required)
- last_name::String (required)

Return: FirstLastNameGeoSubclassificationOut, OpenAPI.Clients.ApiResponse
"""
function subclassification(_api::PersonalApi, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_subclassification(_api, country_iso2, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function subclassification(_api::PersonalApi, response_stream::Channel, country_iso2::String, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_subclassification(_api, country_iso2, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_subclassification_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameGeoSubclassificationOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_subclassification_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_subclassification_batch_PersonalApi, "/api2/json/subclassificationBatch", ["api_key", ], batch_first_last_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code 'IN').

Params:
- batch_first_last_name_geo_in::BatchFirstLastNameGeoIn

Return: BatchFirstLastNameGeoSubclassificationOut, OpenAPI.Clients.ApiResponse
"""
function subclassification_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_subclassification_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function subclassification_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_subclassification_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_subclassification_full_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameGeoSubclassificationOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_subclassification_full(_api::PersonalApi, country_iso2::String, full_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_subclassification_full_PersonalApi, "/api2/json/subclassificationFull/{countryIso2}/{fullName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "countryIso2", country_iso2)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "fullName", full_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code 'IN').

Params:
- country_iso2::String (required)
- full_name::String (required)

Return: FirstLastNameGeoSubclassificationOut, OpenAPI.Clients.ApiResponse
"""
function subclassification_full(_api::PersonalApi, country_iso2::String, full_name::String; _mediaType=nothing)
    _ctx = _oacinternal_subclassification_full(_api, country_iso2, full_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function subclassification_full(_api::PersonalApi, response_stream::Channel, country_iso2::String, full_name::String; _mediaType=nothing)
    _ctx = _oacinternal_subclassification_full(_api, country_iso2, full_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_subclassification_full_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameGeoSubclassificationOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_subclassification_full_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_subclassification_full_batch_PersonalApi, "/api2/json/subclassificationFullBatch", ["api_key", ], batch_personal_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code 'IN').

Params:
- batch_personal_name_geo_in::BatchPersonalNameGeoIn

Return: BatchPersonalNameGeoSubclassificationOut, OpenAPI.Clients.ApiResponse
"""
function subclassification_full_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_subclassification_full_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function subclassification_full_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_subclassification_full_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_us_race_ethnicity_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameUSRaceEthnicityOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_us_race_ethnicity(_api::PersonalApi, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_us_race_ethnicity_PersonalApi, "/api2/json/usRaceEthnicity/{firstName}/{lastName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer a US resident's likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).

Params:
- first_name::String (required)
- last_name::String (required)

Return: FirstLastNameUSRaceEthnicityOut, OpenAPI.Clients.ApiResponse
"""
function us_race_ethnicity(_api::PersonalApi, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity(_api, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function us_race_ethnicity(_api::PersonalApi, response_stream::Channel, first_name::String, last_name::String; _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity(_api, first_name, last_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_us_race_ethnicity_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameUSRaceEthnicityOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_us_race_ethnicity_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_us_race_ethnicity_batch_PersonalApi, "/api2/json/usRaceEthnicityBatch", ["api_key", ], batch_first_last_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer up-to 100 US resident's likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).

Params:
- batch_first_last_name_geo_in::BatchFirstLastNameGeoIn

Return: BatchFirstLastNameUSRaceEthnicityOut, OpenAPI.Clients.ApiResponse
"""
function us_race_ethnicity_batch(_api::PersonalApi; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function us_race_ethnicity_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity_batch(_api; batch_first_last_name_geo_in=batch_first_last_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_us_race_ethnicity_full_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => PersonalNameUSRaceEthnicityOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_us_race_ethnicity_full(_api::PersonalApi, personal_name_full::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_us_race_ethnicity_full_PersonalApi, "/api2/json/usRaceEthnicityFull/{personalNameFull}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "personalNameFull", personal_name_full)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer a US resident's likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).

Params:
- personal_name_full::String (required)

Return: PersonalNameUSRaceEthnicityOut, OpenAPI.Clients.ApiResponse
"""
function us_race_ethnicity_full(_api::PersonalApi, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity_full(_api, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function us_race_ethnicity_full(_api::PersonalApi, response_stream::Channel, personal_name_full::String; _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity_full(_api, personal_name_full; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_us_race_ethnicity_full_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchPersonalNameUSRaceEthnicityOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_us_race_ethnicity_full_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_us_race_ethnicity_full_batch_PersonalApi, "/api2/json/usRaceEthnicityFullBatch", ["api_key", ], batch_personal_name_geo_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer up-to 100 US resident's likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).

Params:
- batch_personal_name_geo_in::BatchPersonalNameGeoIn

Return: BatchPersonalNameUSRaceEthnicityOut, OpenAPI.Clients.ApiResponse
"""
function us_race_ethnicity_full_batch(_api::PersonalApi; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity_full_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function us_race_ethnicity_full_batch(_api::PersonalApi, response_stream::Channel; batch_personal_name_geo_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity_full_batch(_api; batch_personal_name_geo_in=batch_personal_name_geo_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_us_race_ethnicity_z_i_p5_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => FirstLastNameUSRaceEthnicityOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_us_race_ethnicity_z_i_p5(_api::PersonalApi, first_name::String, last_name::String, zip5_code::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_us_race_ethnicity_z_i_p5_PersonalApi, "/api2/json/usRaceEthnicityZIP5/{firstName}/{lastName}/{zip5Code}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "firstName", first_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "lastName", last_name)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "zip5Code", zip5_code)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer a US resident's likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).

Params:
- first_name::String (required)
- last_name::String (required)
- zip5_code::String (required)

Return: FirstLastNameUSRaceEthnicityOut, OpenAPI.Clients.ApiResponse
"""
function us_race_ethnicity_z_i_p5(_api::PersonalApi, first_name::String, last_name::String, zip5_code::String; _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity_z_i_p5(_api, first_name, last_name, zip5_code; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function us_race_ethnicity_z_i_p5(_api::PersonalApi, response_stream::Channel, first_name::String, last_name::String, zip5_code::String; _mediaType=nothing)
    _ctx = _oacinternal_us_race_ethnicity_z_i_p5(_api, first_name, last_name, zip5_code; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_us_zip_race_ethnicity_batch_PersonalApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => BatchFirstLastNameUSRaceEthnicityOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("403", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_us_zip_race_ethnicity_batch(_api::PersonalApi; batch_first_last_name_geo_zipped_in=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_us_zip_race_ethnicity_batch_PersonalApi, "/api2/json/usZipRaceEthnicityBatch", ["api_key", ], batch_first_last_name_geo_zipped_in)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""[USES 10 UNITS PER NAME] Infer up-to 100 US resident's likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).

Params:
- batch_first_last_name_geo_zipped_in::BatchFirstLastNameGeoZippedIn

Return: BatchFirstLastNameUSRaceEthnicityOut, OpenAPI.Clients.ApiResponse
"""
function us_zip_race_ethnicity_batch(_api::PersonalApi; batch_first_last_name_geo_zipped_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_us_zip_race_ethnicity_batch(_api; batch_first_last_name_geo_zipped_in=batch_first_last_name_geo_zipped_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function us_zip_race_ethnicity_batch(_api::PersonalApi, response_stream::Channel; batch_first_last_name_geo_zipped_in=nothing, _mediaType=nothing)
    _ctx = _oacinternal_us_zip_race_ethnicity_batch(_api; batch_first_last_name_geo_zipped_in=batch_first_last_name_geo_zipped_in, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export community_engage
export community_engage_batch
export community_engage_full
export community_engage_full_batch
export corridor
export corridor_batch
export country
export country_batch
export country_fn_ln
export country_fn_ln_batch
export diaspora
export diaspora_batch
export diaspora_full
export diaspora_full_batch
export gender
export gender1
export gender_batch
export gender_full
export gender_full_batch
export gender_full_geo
export gender_full_geo_batch
export gender_geo
export gender_geo_batch
export origin
export origin_batch
export origin_full
export origin_full_batch
export parse_name
export parse_name_batch
export parse_name_geo
export parse_name_geo_batch
export religion2
export religion_batch
export religion_full
export religion_full_batch
export subclassification
export subclassification_batch
export subclassification_full
export subclassification_full_batch
export us_race_ethnicity
export us_race_ethnicity_batch
export us_race_ethnicity_full
export us_race_ethnicity_full_batch
export us_race_ethnicity_z_i_p5
export us_zip_race_ethnicity_batch
