# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct AdminApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `AdminApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ AdminApi }) = "https://v2.namsor.com/NamSorAPIv2"

const _returntypes_anonymize_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_anonymize(_api::AdminApi, source::String, anonymized::Bool; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_anonymize_AdminApi, "/api2/json/anonymize/{source}/{anonymized}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "source", source)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "anonymized", anonymized)  # type Bool
    OpenAPI.Clients.set_header_accept(_ctx, [])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Activate/deactivate anonymization for a source.

Params:
- source::String (required)
- anonymized::Bool (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function anonymize(_api::AdminApi, source::String, anonymized::Bool; _mediaType=nothing)
    _ctx = _oacinternal_anonymize(_api, source, anonymized; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function anonymize(_api::AdminApi, response_stream::Channel, source::String, anonymized::Bool; _mediaType=nothing)
    _ctx = _oacinternal_anonymize(_api, source, anonymized; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_anonymize1_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIKeyOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_anonymize1(_api::AdminApi, source::String, anonymized::Bool, token::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_anonymize1_AdminApi, "/api2/json/anonymize/{source}/{anonymized}/{token}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "source", source)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "anonymized", anonymized)  # type Bool
    OpenAPI.Clients.set_param(_ctx.path, "token", token)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Activate/deactivate anonymization for a source.

Params:
- source::String (required)
- anonymized::Bool (required)
- token::String (required)

Return: APIKeyOut, OpenAPI.Clients.ApiResponse
"""
function anonymize1(_api::AdminApi, source::String, anonymized::Bool, token::String; _mediaType=nothing)
    _ctx = _oacinternal_anonymize1(_api, source, anonymized, token; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function anonymize1(_api::AdminApi, response_stream::Channel, source::String, anonymized::Bool, token::String; _mediaType=nothing)
    _ctx = _oacinternal_anonymize1(_api, source, anonymized, token; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_api_key_info_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIKeyOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_api_key_info(_api::AdminApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_api_key_info_AdminApi, "/api2/json/apiKeyInfo", ["api_key", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Read API Key info.

Params:

Return: APIKeyOut, OpenAPI.Clients.ApiResponse
"""
function api_key_info(_api::AdminApi; _mediaType=nothing)
    _ctx = _oacinternal_api_key_info(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function api_key_info(_api::AdminApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_api_key_info(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_api_status_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIClassifiersStatusOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_api_status(_api::AdminApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_api_status_AdminApi, "/api2/json/apiStatus", ["api_key", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Prints the current status of the classifiers. A classifier name in apiStatus corresponds to a service name in apiServices.

Params:

Return: APIClassifiersStatusOut, OpenAPI.Clients.ApiResponse
"""
function api_status(_api::AdminApi; _mediaType=nothing)
    _ctx = _oacinternal_api_status(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function api_status(_api::AdminApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_api_status(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_api_usage_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIPeriodUsageOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_api_usage(_api::AdminApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_api_usage_AdminApi, "/api2/json/apiUsage", ["api_key", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Print current API usage.

Params:

Return: APIPeriodUsageOut, OpenAPI.Clients.ApiResponse
"""
function api_usage(_api::AdminApi; _mediaType=nothing)
    _ctx = _oacinternal_api_usage(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function api_usage(_api::AdminApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_api_usage(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_api_usage_history_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIUsageHistoryOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_api_usage_history(_api::AdminApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_api_usage_history_AdminApi, "/api2/json/apiUsageHistory", ["api_key", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Print historical API usage.

Params:

Return: APIUsageHistoryOut, OpenAPI.Clients.ApiResponse
"""
function api_usage_history(_api::AdminApi; _mediaType=nothing)
    _ctx = _oacinternal_api_usage_history(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function api_usage_history(_api::AdminApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_api_usage_history(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_api_usage_history_aggregate_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIUsageAggregatedOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_api_usage_history_aggregate(_api::AdminApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_api_usage_history_aggregate_AdminApi, "/api2/json/apiUsageHistoryAggregate", ["api_key", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Print historical API usage (in an aggregated view, by service, by day/hour/min).

Params:

Return: APIUsageAggregatedOut, OpenAPI.Clients.ApiResponse
"""
function api_usage_history_aggregate(_api::AdminApi; _mediaType=nothing)
    _ctx = _oacinternal_api_usage_history_aggregate(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function api_usage_history_aggregate(_api::AdminApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_api_usage_history_aggregate(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_available_services_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIServicesOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_available_services(_api::AdminApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_available_services_AdminApi, "/api2/json/apiServices", ["api_key", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List of classification services and usage cost in Units per classification (default is 1=ONE Unit). Some API endpoints (ex. Corridor) combine multiple classifiers.

Params:

Return: APIServicesOut, OpenAPI.Clients.ApiResponse
"""
function available_services(_api::AdminApi; _mediaType=nothing)
    _ctx = _oacinternal_available_services(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function available_services(_api::AdminApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_available_services(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_disable_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_disable(_api::AdminApi, source::String, disabled::Bool; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_disable_AdminApi, "/api2/json/disable/{source}/{disabled}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "source", source)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "disabled", disabled)  # type Bool
    OpenAPI.Clients.set_header_accept(_ctx, [])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Activate/deactivate an API Key.

Params:
- source::String (required)
- disabled::Bool (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function disable(_api::AdminApi, source::String, disabled::Bool; _mediaType=nothing)
    _ctx = _oacinternal_disable(_api, source, disabled; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function disable(_api::AdminApi, response_stream::Channel, source::String, disabled::Bool; _mediaType=nothing)
    _ctx = _oacinternal_disable(_api, source, disabled; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_learnable_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIKeyOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_learnable(_api::AdminApi, source::String, learnable_param::Bool, token::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_learnable_AdminApi, "/api2/json/learnable/{source}/{learnable}/{token}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "source", source)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "learnable", learnable_param)  # type Bool
    OpenAPI.Clients.set_param(_ctx.path, "token", token)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Activate/deactivate learning from a source.

Params:
- source::String (required)
- learnable_param::Bool (required)
- token::String (required)

Return: APIKeyOut, OpenAPI.Clients.ApiResponse
"""
function learnable(_api::AdminApi, source::String, learnable_param::Bool, token::String; _mediaType=nothing)
    _ctx = _oacinternal_learnable(_api, source, learnable_param, token; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function learnable(_api::AdminApi, response_stream::Channel, source::String, learnable_param::Bool, token::String; _mediaType=nothing)
    _ctx = _oacinternal_learnable(_api, source, learnable_param, token; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_learnable1_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_learnable1(_api::AdminApi, source::String, learnable::Bool; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_learnable1_AdminApi, "/api2/json/learnable/{source}/{learnable}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "source", source)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "learnable", learnable)  # type Bool
    OpenAPI.Clients.set_header_accept(_ctx, [])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Activate/deactivate learning from a source.

Params:
- source::String (required)
- learnable::Bool (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function learnable1(_api::AdminApi, source::String, learnable::Bool; _mediaType=nothing)
    _ctx = _oacinternal_learnable1(_api, source, learnable; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function learnable1(_api::AdminApi, response_stream::Channel, source::String, learnable::Bool; _mediaType=nothing)
    _ctx = _oacinternal_learnable1(_api, source, learnable; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_regions_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => RegionOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_regions(_api::AdminApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_regions_AdminApi, "/api2/json/regions", ["api_key", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Print basic source statistics.

Params:

Return: RegionOut, OpenAPI.Clients.ApiResponse
"""
function regions(_api::AdminApi; _mediaType=nothing)
    _ctx = _oacinternal_regions(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function regions(_api::AdminApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_regions(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_software_version_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SoftwareVersionOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_software_version(_api::AdminApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_software_version_AdminApi, "/api2/json/softwareVersion", ["api_key", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get the current software version

Params:

Return: SoftwareVersionOut, OpenAPI.Clients.ApiResponse
"""
function software_version(_api::AdminApi; _mediaType=nothing)
    _ctx = _oacinternal_software_version(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function software_version(_api::AdminApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_software_version(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_taxonomy_classes_AdminApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => APIClassifierTaxonomyOut,
    Regex("^" * replace("401", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_taxonomy_classes(_api::AdminApi, classifier_name::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_taxonomy_classes_AdminApi, "/api2/json/taxonomyClasses/{classifierName}", ["api_key", ])
    OpenAPI.Clients.set_param(_ctx.path, "classifierName", classifier_name)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Print the taxonomy classes valid for the given classifier.

Params:
- classifier_name::String (required)

Return: APIClassifierTaxonomyOut, OpenAPI.Clients.ApiResponse
"""
function taxonomy_classes(_api::AdminApi, classifier_name::String; _mediaType=nothing)
    _ctx = _oacinternal_taxonomy_classes(_api, classifier_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function taxonomy_classes(_api::AdminApi, response_stream::Channel, classifier_name::String; _mediaType=nothing)
    _ctx = _oacinternal_taxonomy_classes(_api, classifier_name; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export anonymize
export anonymize1
export api_key_info
export api_status
export api_usage
export api_usage_history
export api_usage_history_aggregate
export available_services
export disable
export learnable
export learnable1
export regions
export software_version
export taxonomy_classes
